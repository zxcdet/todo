import { Component, OnDestroy, OnInit } from '@angular/core';import {  AbstractControl,  AsyncValidatorFn,  FormBuilder,  FormGroup,  ValidationErrors,  Validators} from '@angular/forms';import { Router } from '@angular/router';import { MatSnackBar } from '@angular/material/snack-bar';import { Store } from '@ngrx/store';import { Observable, Subject } from 'rxjs';import { takeUntil, tap } from 'rxjs/operators';import { AuthService } from '../../services/auth.service';import { registerAction } from '../../store/actions/register.action';@Component({  selector: 'mc-register',  templateUrl: './register.component.html',  styleUrls: ['./register.component.css']})export class RegisterComponent implements OnInit, OnDestroy {  public form!: FormGroup;  private readonly destroy$ = new Subject();  constructor(    private formBuilder: FormBuilder,    private authService: AuthService,    private router: Router,    private _snackBar: MatSnackBar,    private store: Store  ) {  };  public get isDisable(): boolean {    return this.form.get("email").invalid || this.form.get("password").invalid  };  public get emailControl(): AbstractControl {    return this.form.get("email")  };  public ngOnInit(): void {    this.initializeForm();  };  public onSubmit(): void {    this.authService.register(this.form.value)      .pipe(takeUntil(this.destroy$))      .subscribe(        () => {          this.store.dispatch(registerAction({currentUser: this.form.value}));          this.router.navigate(['todoList-form'])        },        error => {          this._snackBar.open(error.error.message, '', {duration: 3000});          console.warn(error);        }      )  };  public ngOnDestroy(): void {    this.destroy$.next();    this.destroy$.complete();  };  private initializeForm(): void {    this.form = this.formBuilder.group({      email: ['', {        validators: [Validators.required, Validators.email],        asyncValidators: [this.emailValidator()],        updateOn: "change"      }],      password: ['', [Validators.required, Validators.minLength(6)]]    });  };  private emailValidator(): AsyncValidatorFn {    return (control: AbstractControl): Observable<ValidationErrors | null> => {      return this.authService.chackUser(control.value).pipe(        tap(res => {          return res?.message ? {usernameExists: true} : null;        })      );    };  };}